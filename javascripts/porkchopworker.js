// Generated by CoffeeScript 1.3.3
(function() {
  var HEIGHT, WIDTH, injectionDeltaV;

  importScripts('numeric-1.2.6.min.js');

  importScripts('quaternion.js');

  importScripts('orbit.js');

  WIDTH = 300;

  HEIGHT = 300;

  injectionDeltaV = function(initialVelocity, hyperbolicExcessVelocity) {
    var v0, vinf;
    vinf = hyperbolicExcessVelocity;
    v0 = Math.sqrt(vinf * vinf + 2 * initialVelocity * initialVelocity);
    return v0 - initialVelocity;
  };

  this.onmessage = function(event) {
    var arrivalTime, deltaV, deltaVs, departureTime, destinationOrbit, dt, earliestArrival, earliestDeparture, finalOrbitalVelocity, i, initialOrbitalVelocity, lastProgress, longDeltaV, longEjectionDeltaV, longInsertionDeltaV, longWayTransferVelocities, maxDeltaV, minDeltaV, now, nu, originOrbit, originPositions, originVelocities, p1, p2, referenceBody, shortDeltaV, shortEjectionDeltaV, shortInsertionDeltaV, shortWayTransferVelocities, v1, v2, x, xResolution, y, yResolution, _i, _j, _k;
    originOrbit = Orbit.fromJSON(event.data.originOrbit);
    initialOrbitalVelocity = event.data.initialOrbitalVelocity;
    destinationOrbit = Orbit.fromJSON(event.data.destinationOrbit);
    finalOrbitalVelocity = event.data.finalOrbitalVelocity;
    earliestDeparture = event.data.earliestDeparture;
    earliestArrival = event.data.earliestArrival;
    xResolution = event.data.xScale / WIDTH;
    yResolution = event.data.yScale / HEIGHT;
    referenceBody = originOrbit.referenceBody;
    originPositions = [];
    originVelocities = [];
    for (x = _i = 0; 0 <= WIDTH ? _i < WIDTH : _i > WIDTH; x = 0 <= WIDTH ? ++_i : --_i) {
      departureTime = earliestDeparture + x * xResolution;
      nu = originOrbit.trueAnomalyAt(departureTime);
      originPositions[x] = originOrbit.positionAtTrueAnomaly(nu);
      originVelocities[x] = originOrbit.velocityAtTrueAnomaly(nu);
    }
    deltaVs = new Float64Array(WIDTH * HEIGHT);
    i = 0;
    minDeltaV = Infinity;
    maxDeltaV = 0;
    lastProgress = 0;
    for (y = _j = 0; 0 <= HEIGHT ? _j < HEIGHT : _j > HEIGHT; y = 0 <= HEIGHT ? ++_j : --_j) {
      arrivalTime = earliestArrival + ((HEIGHT - 1) - y) * yResolution;
      nu = destinationOrbit.trueAnomalyAt(arrivalTime);
      p2 = destinationOrbit.positionAtTrueAnomaly(nu);
      v2 = destinationOrbit.velocityAtTrueAnomaly(nu);
      for (x = _k = 0; 0 <= WIDTH ? _k < WIDTH : _k > WIDTH; x = 0 <= WIDTH ? ++_k : --_k) {
        departureTime = earliestDeparture + x * xResolution;
        if (arrivalTime <= departureTime) {
          deltaVs[i++] = NaN;
          continue;
        }
        p1 = originPositions[x];
        v1 = originVelocities[x];
        dt = arrivalTime - departureTime;
        shortWayTransferVelocities = Orbit.transferVelocities(referenceBody, p1, p2, dt, false);
        longWayTransferVelocities = Orbit.transferVelocities(referenceBody, p1, p2, dt, true);
        shortEjectionDeltaV = numeric.norm2(numeric.subVV(shortWayTransferVelocities[0], v1));
        longEjectionDeltaV = numeric.norm2(numeric.subVV(longWayTransferVelocities[0], v1));
        if (initialOrbitalVelocity != null) {
          shortEjectionDeltaV = injectionDeltaV(initialOrbitalVelocity, shortEjectionDeltaV);
          longEjectionDeltaV = injectionDeltaV(initialOrbitalVelocity, longEjectionDeltaV);
        }
        if (finalOrbitalVelocity === 0) {
          shortInsertionDeltaV = 0;
          longInsertionDeltaV = 0;
        } else {
          shortInsertionDeltaV = numeric.norm2(numeric.subVV(shortWayTransferVelocities[1], v2));
          longInsertionDeltaV = numeric.norm2(numeric.subVV(longWayTransferVelocities[1], v2));
          if (finalOrbitalVelocity != null) {
            shortInsertionDeltaV = injectionDeltaV(finalOrbitalVelocity, shortInsertionDeltaV);
            longInsertionDeltaV = injectionDeltaV(finalOrbitalVelocity, longInsertionDeltaV);
          }
        }
        shortDeltaV = shortEjectionDeltaV + shortInsertionDeltaV;
        longDeltaV = longEjectionDeltaV + longInsertionDeltaV;
        deltaVs[i++] = deltaV = Math.min(shortDeltaV, longDeltaV);
        minDeltaV = Math.min(deltaV, minDeltaV);
        maxDeltaV = Math.max(deltaV, maxDeltaV);
      }
      now = Date.now();
      if (now - lastProgress > 100) {
        postMessage({
          progress: (y + 1) / HEIGHT
        });
        lastProgress = now;
      }
    }
    try {
      return postMessage({
        deltaVs: deltaVs.buffer,
        minDeltaV: minDeltaV,
        maxDeltaV: maxDeltaV
      }, [deltaVs.buffer]);
    } catch (error) {
      if (error instanceof TypeError) {
        return postMessage({
          deltaVs: deltaVs.buffer,
          minDeltaV: minDeltaV,
          maxDeltaV: maxDeltaV
        });
      } else {
        throw error;
      }
    }
  };

}).call(this);
