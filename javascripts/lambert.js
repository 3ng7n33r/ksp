// Generated by CoffeeScript 1.3.3
(function() {
  var HALF_PI, MACHINE_EPSILON, TWO_PI, acot, acoth, findRoot;

  TWO_PI = 2 * Math.PI;

  HALF_PI = 0.5 * Math.PI;

  MACHINE_EPSILON = 1.0;

  while ((1.0 + MACHINE_EPSILON) !== 1.0) {
    MACHINE_EPSILON *= 0.5;
  }

  acot = function(x) {
    return HALF_PI - Math.atan(x);
  };

  acoth = function(x) {
    return 0.5 * Math.log((x + 1) / (x - 1));
  };

  findRoot = function(a, b, relativeAccuracy, f, df, ddf) {
    var c, d, e, fa, fb, fc, i, m, p, q, r, s, tol;
    c = a;
    fa = f(a);
    fb = f(b);
    fc = fa;
    d = b - a;
    e = d;
    i = 0;
    while (true) {
      if (Math.abs(fc) < Math.abs(fb)) {
        a = b;
        b = c;
        c = a;
        fa = fb;
        fb = fc;
        fc = fa;
      }
      tol = (0.5 * MACHINE_EPSILON + relativeAccuracy) * Math.abs(b);
      m = 0.5 * (c - b);
      if (fb === 0 || Math.abs(m) <= tol) {
        return b;
      }
      if (i > 100) {
        throw "Brent's method failed to converge after 100 iterations";
      }
      if (Math.abs(e) < tol || Math.abs(fa) <= Math.abs(fb)) {
        d = e = m;
      } else {
        s = fb / fa;
        if (a === c) {
          p = 2 * m * s;
          q = 1 - s;
        } else {
          q = fa / fc;
          r = fb / fc;
          p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));
          q = (q - 1) * (r - 1) * (s - 1);
        }
        if (p > 0) {
          q = -q;
        } else {
          p = -p;
        }
        if (2 * p < Math.min(3 * m * q - Math.abs(tol * q), Math.abs(e * q))) {
          e = d;
          d = p / q;
        } else {
          d = e = m;
        }
      }
      a = b;
      fa = fb;
      if (Math.abs(d) > tol) {
        b += d;
      } else {
        b += m > 0 ? tol : -tol;
      }
      fb = f(b);
      if ((fb < 0 && fc < 0) || (fb > 0 && fc > 0)) {
        c = a;
        fc = fa;
        d = e = b - a;
      }
      i++;
    }
  };

  this.lambert = function(mu, pos1, pos2, dt) {
    var angleParameter, c, cosHalfTransferAngle, deltaPos, ec, ftau, fy, invSqrtM, invSqrtN, m, minimumEnergyNormalizedTime, n, normalizedTime, parabolicNormalizedTime, r1, r2, sqrtMu, transferAngle, v1, v2, vc, vr, x, x1, x2, y;
    r1 = numeric.norm2(pos1);
    r2 = numeric.norm2(pos2);
    deltaPos = numeric.subVV(pos2, pos1);
    c = numeric.norm2(deltaPos);
    m = r1 + r2 + c;
    n = r1 + r2 - c;
    transferAngle = Math.acos(numeric.dot(pos1, pos2) / (r1 * r2));
    if (pos1[0] * pos2[1] - pos1[1] * pos2[0] < 0) {
      transferAngle = TWO_PI - transferAngle;
    }
    cosHalfTransferAngle = Math.cos(transferAngle / 2);
    angleParameter = Math.sqrt(4 * r1 * r2 / (m * m) * cosHalfTransferAngle * cosHalfTransferAngle);
    if (transferAngle > Math.PI) {
      angleParameter = -angleParameter;
    }
    normalizedTime = 4 * dt * Math.sqrt(mu / (m * m * m));
    parabolicNormalizedTime = 2 / 3 * (1 - angleParameter * angleParameter * angleParameter);
    minimumEnergyNormalizedTime = Math.acos(angleParameter) + angleParameter * Math.sqrt(1 - angleParameter * angleParameter);
    fy = function(x) {
      var y;
      y = Math.sqrt(1 - angleParameter * angleParameter * (1 - x * x));
      if (angleParameter < 0) {
        return -y;
      } else {
        return y;
      }
    };
    if (normalizedTime === parabolicNormalizedTime) {
      x = 1.0;
      y = angleParameter < 0 ? -1 : 1;
    } else if (normalizedTime === minimumEnergyNormalizedTime) {
      x = 0.0;
      y = fy(x);
    } else {
      ftau = function(x) {
        var g, h;
        if (x === 1.0) {
          return parabolicNormalizedTime - normalizedTime;
        } else {
          y = fy(x);
          if (x > 1) {
            g = Math.sqrt(x * x - 1);
            h = Math.sqrt(y * y - 1);
            return (-acoth(x / g) + acoth(y / h) + x * g - y * h) / (g * g * g) - normalizedTime;
          } else {
            g = Math.sqrt(1 - x * x);
            h = Math.sqrt(1 - y * y);
            return (acot(x / g) - Math.atan(h / y) - x * g + y * h) / (g * g * g) - normalizedTime;
          }
        }
      };
      if (normalizedTime > parabolicNormalizedTime) {
        if (normalizedTime < minimumEnergyNormalizedTime) {
          x1 = 0.0;
          x2 = 1.0;
        } else {
          x1 = -1.0 + MACHINE_EPSILON;
          x2 = 0.0;
        }
      } else {
        x1 = 1.0;
        x2 = 2.0;
        while (!(ftau(x2) < 0.0)) {
          x1 = x2;
          x2 *= 2.0;
        }
      }
      x = findRoot(x1, x2, 1e-4, ftau);
      y = fy(x);
    }
    sqrtMu = Math.sqrt(mu);
    invSqrtM = 1 / Math.sqrt(m);
    invSqrtN = 1 / Math.sqrt(n);
    vc = sqrtMu * (y * invSqrtN + x * invSqrtM);
    vr = sqrtMu * (y * invSqrtN - x * invSqrtM);
    ec = numeric.mulVS(deltaPos, vc / c);
    v1 = numeric.addVV(ec, numeric.mulVS(pos1, vr / r1));
    v2 = numeric.subVV(ec, numeric.mulVS(pos2, vr / r2));
    return [v1, v2];
  };

}).call(this);
