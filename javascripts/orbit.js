// Generated by CoffeeScript 1.3.3
(function() {
  var Orbit, acosh, clamp, cosh, gaussTimeOfFlight, sinh;

  sinh = function(angle) {
    var p;
    p = Math.exp(angle);
    return (p - (1 / p)) * 0.5;
  };

  cosh = function(angle) {
    var p;
    p = Math.exp(angle);
    return (p + (1 / p)) * 0.5;
  };

  acosh = function(n) {
    return Math.log(n + Math.sqrt(n * n - 1));
  };

  clamp = function(n, min, max) {
    return Math.max(min, Math.min(n, max));
  };

  (typeof exports !== "undefined" && exports !== null ? exports : this).Orbit = Orbit = (function() {

    function Orbit(referenceBody, semiMajorAxis, eccentricity, inclination, longitudeOfAscendingNode, argumentOfPeriapsis, meanAnomalyAtEpoch) {
      var hash;
      this.referenceBody = referenceBody;
      this.semiMajorAxis = semiMajorAxis;
      this.eccentricity = eccentricity;
      this.meanAnomalyAtEpoch = meanAnomalyAtEpoch;
      if (arguments.length === 1) {
        hash = this.referenceBody;
        this.referenceBody = hash.referenceBody;
        this.semiMajorAxis = hash.semiMajorAxis;
        this.eccentricity = hash.eccentricity;
        this.inclination = hash.inclination;
        this.longitudeOfAscendingNode = hash.longitudeOfAscendingNode;
        this.argumentOfPeriapsis = hash.argumentOfPeriapsis;
        this.meanAnomalyAtEpoch = hash.meanAnomalyAtEpoch;
      } else {
        this.inclination = inclination * Math.PI / 180;
        this.longitudeOfAscendingNode = longitudeOfAscendingNode * Math.PI / 180;
        this.argumentOfPeriapsis = argumentOfPeriapsis * Math.PI / 180;
      }
    }

    Orbit.prototype.apoapsis = function() {
      return this.semiMajorAxis * (1 + this.eccentricity);
    };

    Orbit.prototype.periapsis = function() {
      return this.semiMajorAxis * (1 - this.eccentricity);
    };

    Orbit.prototype.apoapsisAltitude = function() {
      return this.apoapsis() - this.referenceBody.radius;
    };

    Orbit.prototype.periapsisAltitude = function() {
      return this.periapsis() - this.referenceBody.radius;
    };

    Orbit.prototype.semiMinorAxis = function() {
      var e;
      e = this.eccentricity;
      return this.semiMajorAxis * Math.sqrt(1 - e * e);
    };

    Orbit.prototype.semiLatusRectum = function() {
      var e;
      e = this.eccentricity;
      return this.semiMajorAxis * (1 - e * e);
    };

    Orbit.prototype.meanMotion = function() {
      var a;
      a = this.semiMajorAxis;
      return Math.sqrt(this.referenceBody.gravitationalParameter / (a * a * a));
    };

    Orbit.prototype.period = function() {
      return 2 * Math.PI / this.meanMotion();
    };

    Orbit.prototype.rotationToReferenceFrame = function() {
      var axisOfInclination;
      axisOfInclination = [Math.cos(-this.argumentOfPeriapsis), Math.sin(-this.argumentOfPeriapsis), 0];
      return quaternion.concat(quaternion.fromAngleAxis(this.longitudeOfAscendingNode + this.argumentOfPeriapsis, [0, 0, 1]), quaternion.fromAngleAxis(this.inclination, axisOfInclination));
    };

    Orbit.prototype.meanAnomalyAt = function(t) {
      return this.meanAnomalyAtEpoch + this.meanMotion() * (t % this.period());
    };

    Orbit.prototype.eccentricAnomalyAt = function(t) {
      var E, E0, M;
      E = M = this.meanAnomalyAt(t);
      while (true) {
        E0 = E;
        E = M + this.eccentricity * Math.sin(E0);
        if (Math.abs(E - E0) < 1e-6) {
          return E;
        }
      }
    };

    Orbit.prototype.trueAnomalyAt = function(t) {
      var E, tA;
      E = this.eccentricAnomalyAt(t);
      tA = 2 * Math.atan(Math.sqrt((1 + this.eccentricity) / (1 - this.eccentricity)) * Math.tan(E / 2));
      if (tA < 0) {
        return tA + 2 * Math.PI;
      } else {
        return tA;
      }
    };

    Orbit.prototype.eccentricAnomalyAtTrueAnomaly = function(tA) {
      var E;
      E = 2 * Math.atan(Math.tan(tA / 2) / Math.sqrt((1 + this.eccentricity) / (1 - this.eccentricity)));
      if (E < 0) {
        return E + 2 * Math.PI;
      } else {
        return E;
      }
    };

    Orbit.prototype.meanAnomalyAtTrueAnomaly = function(tA) {
      var E;
      E = this.eccentricAnomalyAtTrueAnomaly(tA);
      return E - this.eccentricity * Math.sin(E);
    };

    Orbit.prototype.timeAtTrueAnomaly = function(tA) {
      return this.meanAnomalyAtTrueAnomaly(tA) / this.meanMotion();
    };

    Orbit.prototype.radiusAtTrueAnomaly = function(tA) {
      var e;
      e = this.eccentricity;
      return this.semiMajorAxis * (1 - e * e) / (1 + e * Math.cos(tA));
    };

    Orbit.prototype.altitudeAtTrueAnomaly = function(tA) {
      return this.radiusAtTrueAnomaly(tA) - this.referenceBody.radius;
    };

    Orbit.prototype.speedAtTrueAnomaly = function(tA) {
      return Math.sqrt(this.referenceBody.gravitationalParameter * (2 / this.radiusAtTrueAnomaly(tA) - 1 / this.semiMajorAxis));
    };

    Orbit.prototype.positionAtTrueAnomaly = function(tA) {
      var r;
      r = this.radiusAtTrueAnomaly(tA);
      return quaternion.rotate(this.rotationToReferenceFrame(), [r * Math.cos(tA), r * Math.sin(tA), 0]);
    };

    Orbit.prototype.velocityAtTrueAnomaly = function(tA) {
      var cos, e, h, mu, r, sin, vr, vtA;
      mu = this.referenceBody.gravitationalParameter;
      e = this.eccentricity;
      h = Math.sqrt(mu * this.semiMajorAxis * (1 - e * e));
      r = this.radiusAtTrueAnomaly(tA);
      sin = Math.sin(tA);
      cos = Math.cos(tA);
      vr = mu * e * sin / h;
      vtA = h / r;
      return quaternion.rotate(this.rotationToReferenceFrame(), [vr * cos - vtA * sin, vr * sin + vtA * cos, 0]);
    };

    Orbit.prototype.transferDeltaV = function(orbit, t1, t2) {
      var longDeltaV, longWayTransferVelocities, nu1, nu2, position1, position2, shortDeltaV, shortWayTransferVelocities, velocity1, velocity2;
      nu1 = this.trueAnomalyAt(t1);
      position1 = this.positionAtTrueAnomaly(nu1);
      velocity1 = this.velocityAtTrueAnomaly(nu1);
      nu2 = orbit.trueAnomalyAt(t2);
      position2 = orbit.positionAtTrueAnomaly(nu2);
      velocity2 = orbit.velocityAtTrueAnomaly(nu2);
      shortWayTransferVelocities = Orbit.transferVelocities(this.referenceBody, position1, position2, t2 - t1, false);
      longWayTransferVelocities = Orbit.transferVelocities(this.referenceBody, position1, position2, t2 - t1, true);
      shortDeltaV = numeric.norm2(numeric.subVV(velocity1, shortWayTransferVelocities[0])) + numeric.norm2(numeric.subVV(velocity2, shortWayTransferVelocities[1]));
      longDeltaV = numeric.norm2(numeric.subVV(velocity1, longWayTransferVelocities[0])) + numeric.norm2(numeric.subVV(velocity2, longWayTransferVelocities[1]));
      return Math.min(shortDeltaV, longDeltaV);
    };

    return Orbit;

  })();

  Orbit.fromApoapsisAndPeriapsis = function(referenceBody, apoapsis, periapsis, inclination, longitudeOfAscendingNode, argumentOfPeriapsis, meanAnomalyAtEpoch) {
    var eccentricity, semiMajorAxis, _ref;
    if (apoapsis < periapsis) {
      _ref = [periapsis, apoapsis], apoapsis = _ref[0], periapsis = _ref[1];
    }
    semiMajorAxis = (apoapsis + periapsis) / 2;
    eccentricity = apoapsis / semiMajorAxis - 1;
    return new Orbit(referenceBody, semiMajorAxis, eccentricity, inclination, longitudeOfAscendingNode, argumentOfPeriapsis, meanAnomalyAtEpoch);
  };

  Orbit.fromAltitudeAndVelocity = function(referenceBody, altitude, speed, flightPathAngle, heading, latitude, longitude, t) {
    var angleToAscendingNode, cosPhi, e, eccentricity, meanAnomaly, mu, orbit, radius, semiMajorAxis, sinPhi, trueAnomaly;
    radius = referenceBody.radius + altitude;
    flightPathAngle = flightPathAngle * Math.PI / 180;
    if (heading != null) {
      heading = heading * Math.PI / 180;
    }
    mu = referenceBody.gravitationalParameter;
    sinPhi = Math.sin(flightPathAngle);
    cosPhi = Math.cos(flightPathAngle);
    semiMajorAxis = 1 / (2 / radius - speed * speed / mu);
    eccentricity = Math.sqrt(Math.pow(radius * speed * speed / mu - 1, 2) * cosPhi * cosPhi + sinPhi * sinPhi);
    orbit = new Orbit(referenceBody, semiMajorAxis, eccentricity, 0, 0, 0, 0);
    e = eccentricity;
    trueAnomaly = Math.acos((this.semiMajorAxis * (1 - e * e) / radius - 1) / e);
    if (flightPathAngle < 0) {
      trueAnomaly = 2 * Math.PI - trueAnomaly;
    }
    meanAnomaly = orbit.meanAnomalyAtTrueAnomaly(trueAnomaly);
    orbit.meanAnomalyAtEpoch = meanAnomaly - orbit.meanMotion() * (t % orbit.period());
    if ((heading != null) && (latitude != null)) {
      orbit.inclination = Math.acos(Math.cos(latitude) * Math.sin(heading));
      angleToAscendingNode = Math.atan(Math.tan(latitude) / Math.cos(heading));
      orbit.argumentOfPeriapsis = angleToAscendingNode - trueAnomaly;
      if (longitude != null) {
        false;
      }
    }
    return orbit;
  };

  gaussTimeOfFlight = function(mu, r1, r2, deltaNu, k, l, m, p) {
    var a, dE, dF, df, f, g, sinDeltaE;
    a = m * k * p / ((2 * m - l * l) * p * p + 2 * k * l * p - k * k);
    f = 1 - r2 / p * (1 - Math.cos(deltaNu));
    g = r1 * r2 * Math.sin(deltaNu) / Math.sqrt(mu * p);
    df = Math.sqrt(mu / p) * Math.tan(deltaNu / 2) * ((1 - Math.cos(deltaNu)) / p - 1 / r1 - 1 / r2);
    if (a > 0) {
      dE = Math.acos(1 - r1 / a * (1 - f));
      sinDeltaE = -r1 * r2 * df / Math.sqrt(mu * a);
      if (sinDeltaE < 0) {
        dE = 2 * Math.PI - dE;
      }
      return g + Math.sqrt(a * a * a / mu) * (dE - sinDeltaE);
    } else {
      dF = acosh(1 - r1 / a * (1 - f));
      return g + Math.sqrt(-a * a * a / mu) * (sinh(dF) - dF);
    }
  };

  Orbit.transferVelocities = function(referenceBody, position1, position2, dt, longWay) {
    var a, cosDeltaNu, deltaNu, df, dg, f, g, k, l, m, mu, p, p0, p1, r1, r2, t, t0, t1, v1, v2;
    mu = referenceBody.gravitationalParameter;
    r1 = numeric.norm2(position1);
    r2 = numeric.norm2(position2);
    cosDeltaNu = numeric.dot(position1, position2) / (r1 * r2);
    deltaNu = Math.acos(cosDeltaNu);
    if (longWay) {
      deltaNu = 2 * Math.PI - deltaNu;
    }
    if (Math.abs(cosDeltaNu) === 1) {
      throw new Error("Unable find orbit between collinear points");
    }
    k = r1 * r2 * (1 - cosDeltaNu);
    l = r1 + r2;
    m = r1 * r2 * (1 + cosDeltaNu);
    if (longWay) {
      p0 = k / (l - Math.sqrt(2 * m));
      p1 = p0 * 1e-3;
      p0 *= 0.999999;
    } else {
      p0 = k / (l + Math.sqrt(2 * m));
      p1 = p0 * 1e3;
      p0 *= 1.000001;
    }
    t0 = gaussTimeOfFlight(mu, r1, r2, deltaNu, k, l, m, p0);
    t1 = gaussTimeOfFlight(mu, r1, r2, deltaNu, k, l, m, p1);
    if (t0 < dt) {
      p = p0;
    } else if (t1 > dt) {
      p = p1;
    } else {
      while (true) {
        p = (p0 + p1) / 2;
        if (p === p0 || p === p1) {
          break;
        }
        t = gaussTimeOfFlight(mu, r1, r2, deltaNu, k, l, m, p);
        if (Math.abs(1 - t / dt) < 1e-6) {
          break;
        }
        if (t < dt) {
          p1 = p;
        } else {
          p0 = p;
        }
      }
    }
    a = m * k * p / ((2 * m - l * l) * p * p + 2 * k * l * p - k * k);
    f = 1 - r2 / p * (1 - cosDeltaNu);
    g = r1 * r2 * Math.sin(deltaNu) / Math.sqrt(mu * p);
    df = Math.sqrt(mu / p) * Math.tan(deltaNu / 2) * ((1 - cosDeltaNu) / p - 1 / r1 - 1 / r2);
    dg = 1 - r1 / p * (1 - cosDeltaNu);
    v1 = numeric.mulVS(numeric.subVV(position2, numeric.mulVS(position1, f)), 1 / g);
    v2 = numeric.addVV(numeric.mulVS(position1, df), numeric.mulVS(v1, dg));
    return [v1, v2];
  };

}).call(this);
